
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

// DO NOT EDIT THIS FILE! It IS AUTOGENERATED
#include <stdarg.h>
#include <stdlib.h>
#include "corinfoexception.h"

struct CORINFO_LOOKUP_KIND;

class IJitInterface
{
public:
    virtual unsigned int getMethodAttribs(CorInfoException** ppException, void* ftn) = 0;
    virtual void setMethodAttribs(CorInfoException** ppException, void* ftn, int attribs) = 0;
    virtual void getMethodSig(CorInfoException** ppException, void* ftn, void* sig, void* memberParent) = 0;
    virtual bool getMethodInfo(CorInfoException** ppException, void* ftn, void* info) = 0;
    virtual int canInline(CorInfoException** ppException, void* callerHnd, void* calleeHnd, unsigned int* pRestrictions) = 0;
    virtual void reportInliningDecision(CorInfoException** ppException, void* inlinerHnd, void* inlineeHnd, int inlineResult, const char* reason) = 0;
    virtual bool canTailCall(CorInfoException** ppException, void* callerHnd, void* declaredCalleeHnd, void* exactCalleeHnd, bool fIsTailPrefix) = 0;
    virtual void reportTailCallDecision(CorInfoException** ppException, void* callerHnd, void* calleeHnd, bool fIsTailPrefix, int tailCallResult, const char* reason) = 0;
    virtual void getEHinfo(CorInfoException** ppException, void* ftn, unsigned EHnumber, void* clause) = 0;
    virtual void* getMethodClass(CorInfoException** ppException, void* method) = 0;
    virtual void* getMethodModule(CorInfoException** ppException, void* method) = 0;
    virtual void getMethodVTableOffset(CorInfoException** ppException, void* method, unsigned* offsetOfIndirection, unsigned* offsetAfterIndirection) = 0;
    virtual int getIntrinsicID(CorInfoException** ppException, void* method) = 0;
    virtual bool isInSIMDModule(CorInfoException** ppException, void* classHnd) = 0;
    virtual int getUnmanagedCallConv(CorInfoException** ppException, void* method) = 0;
    virtual bool pInvokeMarshalingRequired(CorInfoException** ppException, void* method, void* callSiteSig) = 0;
    virtual bool satisfiesMethodConstraints(CorInfoException** ppException, void* parent, void* method) = 0;
    virtual bool isCompatibleDelegate(CorInfoException** ppException, void* objCls, void* methodParentCls, void* method, void* delegateCls, int* pfIsOpenDelegate) = 0;
    virtual bool isDelegateCreationAllowed(CorInfoException** ppException, void* delegateHnd, void* calleeHnd) = 0;
    virtual int isInstantiationOfVerifiedGeneric(CorInfoException** ppException, void* method) = 0;
    virtual void initConstraintsForVerification(CorInfoException** ppException, void* method, int* pfHasCircularClassConstraints, int* pfHasCircularMethodConstraint) = 0;
    virtual int canSkipMethodVerification(CorInfoException** ppException, void* ftnHandle) = 0;
    virtual void methodMustBeLoadedBeforeCodeIsRun(CorInfoException** ppException, void* method) = 0;
    virtual void* mapMethodDeclToMethodImpl(CorInfoException** ppException, void* method) = 0;
    virtual void getGSCookie(CorInfoException** ppException, void* pCookieVal, void** ppCookieVal) = 0;
    virtual void resolveToken(CorInfoException** ppException, void* pResolvedToken) = 0;
    virtual void findSig(CorInfoException** ppException, void* module, unsigned sigTOK, void* context, void* sig) = 0;
    virtual void findCallSiteSig(CorInfoException** ppException, void* module, unsigned methTOK, void* context, void* sig) = 0;
    virtual void* getTokenTypeAsHandle(CorInfoException** ppException, void* pResolvedToken) = 0;
    virtual int canSkipVerification(CorInfoException** ppException, void* module) = 0;
    virtual bool isValidToken(CorInfoException** ppException, void* module, unsigned metaTOK) = 0;
    virtual bool isValidStringRef(CorInfoException** ppException, void* module, unsigned metaTOK) = 0;
    virtual bool shouldEnforceCallvirtRestriction(CorInfoException** ppException, void* scope) = 0;
    virtual int asCorInfoType(CorInfoException** ppException, void* cls) = 0;
    virtual const char* getClassName(CorInfoException** ppException, void* cls) = 0;
    virtual int appendClassName(CorInfoException** ppException, wchar_t** ppBuf, int* pnBufLen, void* cls, bool fNamespace, bool fFullInst, bool fAssembly) = 0;
    virtual bool isValueClass(CorInfoException** ppException, void* cls) = 0;
    virtual bool canInlineTypeCheckWithObjectVTable(CorInfoException** ppException, void* cls) = 0;
    virtual unsigned int getClassAttribs(CorInfoException** ppException, void* cls) = 0;
    virtual bool isStructRequiringStackAllocRetBuf(CorInfoException** ppException, void* cls) = 0;
    virtual void* getClassModule(CorInfoException** ppException, void* cls) = 0;
    virtual void* getModuleAssembly(CorInfoException** ppException, void* mod) = 0;
    virtual const char* getAssemblyName(CorInfoException** ppException, void* assem) = 0;
    virtual void* LongLifetimeMalloc(CorInfoException** ppException, size_t sz) = 0;
    virtual void LongLifetimeFree(CorInfoException** ppException, void* obj) = 0;
    virtual size_t getClassModuleIdForStatics(CorInfoException** ppException, void* cls, void* pModule, void** ppIndirection) = 0;
    virtual unsigned getClassSize(CorInfoException** ppException, void* cls) = 0;
    virtual unsigned getClassAlignmentRequirement(CorInfoException** ppException, void* cls, bool fDoubleAlignHint) = 0;
    virtual unsigned getClassGClayout(CorInfoException** ppException, void* cls, unsigned char* gcPtrs) = 0;
    virtual unsigned getClassNumInstanceFields(CorInfoException** ppException, void* cls) = 0;
    virtual void* getFieldInClass(CorInfoException** ppException, void* clsHnd, int num) = 0;
    virtual bool checkMethodModifier(CorInfoException** ppException, void* hMethod, const char* modifier, bool fOptional) = 0;
    virtual int getNewHelper(CorInfoException** ppException, void* pResolvedToken, void* callerHandle) = 0;
    virtual int getNewArrHelper(CorInfoException** ppException, void* arrayCls) = 0;
    virtual int getCastingHelper(CorInfoException** ppException, void* pResolvedToken, bool fThrowing) = 0;
    virtual int getSharedCCtorHelper(CorInfoException** ppException, void* clsHnd) = 0;
    virtual int getSecurityPrologHelper(CorInfoException** ppException, void* ftn) = 0;
    virtual void* getTypeForBox(CorInfoException** ppException, void* cls) = 0;
    virtual int getBoxHelper(CorInfoException** ppException, void* cls) = 0;
    virtual int getUnBoxHelper(CorInfoException** ppException, void* cls) = 0;
    virtual void getReadyToRunHelper(CorInfoException** ppException, void* pResolvedToken, int id, void* pLookup) = 0;
    virtual const char* getHelperName(CorInfoException** ppException, int helpFunc) = 0;
    virtual int initClass(CorInfoException** ppException, void* field, void* method, void* context, bool speculative) = 0;
    virtual void classMustBeLoadedBeforeCodeIsRun(CorInfoException** ppException, void* cls) = 0;
    virtual void* getBuiltinClass(CorInfoException** ppException, int classId) = 0;
    virtual int getTypeForPrimitiveValueClass(CorInfoException** ppException, void* cls) = 0;
    virtual bool canCast(CorInfoException** ppException, void* child, void* parent) = 0;
    virtual bool areTypesEquivalent(CorInfoException** ppException, void* cls1, void* cls2) = 0;
    virtual void* mergeClasses(CorInfoException** ppException, void* cls1, void* cls2) = 0;
    virtual void* getParentType(CorInfoException** ppException, void* cls) = 0;
    virtual int getChildType(CorInfoException** ppException, void* clsHnd, void* clsRet) = 0;
    virtual bool satisfiesClassConstraints(CorInfoException** ppException, void* cls) = 0;
    virtual bool isSDArray(CorInfoException** ppException, void* cls) = 0;
    virtual unsigned getArrayRank(CorInfoException** ppException, void* cls) = 0;
    virtual void* getArrayInitializationData(CorInfoException** ppException, void* field, unsigned int size) = 0;
    virtual int canAccessClass(CorInfoException** ppException, void* pResolvedToken, void* callerHandle, void* pAccessHelper) = 0;
    virtual const char* getFieldName(CorInfoException** ppException, void* ftn, const char** moduleName) = 0;
    virtual void* getFieldClass(CorInfoException** ppException, void* field) = 0;
    virtual int getFieldType(CorInfoException** ppException, void* field, void* structType, void* memberParent) = 0;
    virtual unsigned getFieldOffset(CorInfoException** ppException, void* field) = 0;
    virtual bool isWriteBarrierHelperRequired(CorInfoException** ppException, void* field) = 0;
    virtual void getFieldInfo(CorInfoException** ppException, void* pResolvedToken, void* callerHandle, int flags, void* pResult) = 0;
    virtual bool isFieldStatic(CorInfoException** ppException, void* fldHnd) = 0;
    virtual void getBoundaries(CorInfoException** ppException, void* ftn, unsigned int* cILOffsets, unsigned int** pILOffsets, void* implictBoundaries) = 0;
    virtual void setBoundaries(CorInfoException** ppException, void* ftn, unsigned int cMap, void* pMap) = 0;
    virtual void getVars(CorInfoException** ppException, void* ftn, unsigned int* cVars, void* vars, bool* extendOthers) = 0;
    virtual void setVars(CorInfoException** ppException, void* ftn, unsigned int cVars, void* vars) = 0;
    virtual void* allocateArray(CorInfoException** ppException, unsigned int cBytes) = 0;
    virtual void freeArray(CorInfoException** ppException, void* array) = 0;
    virtual void* getArgNext(CorInfoException** ppException, void* args) = 0;
    virtual int getArgType(CorInfoException** ppException, void* sig, void* args, void* vcTypeRet) = 0;
    virtual void* getArgClass(CorInfoException** ppException, void* sig, void* args) = 0;
    virtual int getHFAType(CorInfoException** ppException, void* hClass) = 0;
    virtual int GetErrorHRESULT(CorInfoException** ppException, void* pExceptionPointers) = 0;
    virtual unsigned int GetErrorMessage(CorInfoException** ppException, wchar_t* buffer, unsigned int bufferLength) = 0;
    virtual int FilterException(CorInfoException** ppException, void* pExceptionPointers) = 0;
    virtual void HandleException(CorInfoException** ppException, void* pExceptionPointers) = 0;
    virtual void ThrowExceptionForJitResult(CorInfoException** ppException, int result) = 0;
    virtual void ThrowExceptionForHelper(CorInfoException** ppException, const void* throwHelper) = 0;
    virtual void getEEInfo(CorInfoException** ppException, void* pEEInfoOut) = 0;
    virtual const wchar_t* getJitTimeLogFilename(CorInfoException** ppException) = 0;
    virtual unsigned int getMethodDefFromMethod(CorInfoException** ppException, void* hMethod) = 0;
    virtual const char* getMethodName(CorInfoException** ppException, void* ftn, const char** moduleName) = 0;
    virtual unsigned getMethodHash(CorInfoException** ppException, void* ftn) = 0;
    virtual size_t findNameOfToken(CorInfoException** ppException, void* moduleHandle, unsigned int token, char* szFQName, size_t FQNameCapacity) = 0;
    virtual bool getSystemVAmd64PassStructInRegisterDescriptor(CorInfoException** ppException, void* structHnd, void* structPassInRegDescPtr) = 0;
    virtual int getIntConfigValue(CorInfoException** ppException, const wchar_t* name, int defaultValue) = 0;
    virtual wchar_t* getStringConfigValue(CorInfoException** ppException, const wchar_t* name) = 0;
    virtual void freeStringConfigValue(CorInfoException** ppException, wchar_t* value) = 0;
    virtual unsigned int getThreadTLSIndex(CorInfoException** ppException, void** ppIndirection) = 0;
    virtual const void* getInlinedCallFrameVptr(CorInfoException** ppException, void** ppIndirection) = 0;
    virtual long* getAddrOfCaptureThreadGlobal(CorInfoException** ppException, void** ppIndirection) = 0;
    virtual size_t* getAddrModuleDomainID(CorInfoException** ppException, void* module) = 0;
    virtual void* getHelperFtn(CorInfoException** ppException, int ftnNum, void** ppIndirection) = 0;
    virtual void getFunctionEntryPoint(CorInfoException** ppException, void* ftn, void* pResult, int accessFlags) = 0;
    virtual void getFunctionFixedEntryPoint(CorInfoException** ppException, void* ftn, void* pResult) = 0;
    virtual void* getMethodSync(CorInfoException** ppException, void* ftn, void** ppIndirection) = 0;
    virtual int getLazyStringLiteralHelper(CorInfoException** ppException, void* handle) = 0;
    virtual void* embedModuleHandle(CorInfoException** ppException, void* handle, void** ppIndirection) = 0;
    virtual void* embedClassHandle(CorInfoException** ppException, void* handle, void** ppIndirection) = 0;
    virtual void* embedMethodHandle(CorInfoException** ppException, void* handle, void** ppIndirection) = 0;
    virtual void* embedFieldHandle(CorInfoException** ppException, void* handle, void** ppIndirection) = 0;
    virtual void embedGenericHandle(CorInfoException** ppException, void* pResolvedToken, bool fEmbedParent, void* pResult) = 0;
    virtual void getLocationOfThisType(CorInfoException** ppException, CORINFO_LOOKUP_KIND* _return, void* context) = 0;
    virtual void* getPInvokeUnmanagedTarget(CorInfoException** ppException, void* method, void** ppIndirection) = 0;
    virtual void* getAddressOfPInvokeFixup(CorInfoException** ppException, void* method, void** ppIndirection) = 0;
    virtual void* GetCookieForPInvokeCalliSig(CorInfoException** ppException, void* szMetaSig, void** ppIndirection) = 0;
    virtual bool canGetCookieForPInvokeCalliSig(CorInfoException** ppException, void* szMetaSig) = 0;
    virtual void* getJustMyCodeHandle(CorInfoException** ppException, void* method, void** ppIndirection) = 0;
    virtual void GetProfilingHandle(CorInfoException** ppException, int* pbHookFunction, void** pProfilerHandle, int* pbIndirectedHandles) = 0;
    virtual void getCallInfo(CorInfoException** ppException, void* pResolvedToken, void* pConstrainedResolvedToken, void* callerHandle, int flags, void* pResult) = 0;
    virtual bool canAccessFamily(CorInfoException** ppException, void* hCaller, void* hInstanceType) = 0;
    virtual bool isRIDClassDomainID(CorInfoException** ppException, void* cls) = 0;
    virtual unsigned getClassDomainID(CorInfoException** ppException, void* cls, void** ppIndirection) = 0;
    virtual void* getFieldAddress(CorInfoException** ppException, void* field, void** ppIndirection) = 0;
    virtual void* getVarArgsHandle(CorInfoException** ppException, void* pSig, void** ppIndirection) = 0;
    virtual bool canGetVarArgsHandle(CorInfoException** ppException, void* pSig) = 0;
    virtual int constructStringLiteral(CorInfoException** ppException, void* module, unsigned int metaTok, void** ppValue) = 0;
    virtual int emptyStringLiteral(CorInfoException** ppException, void** ppValue) = 0;
    virtual unsigned int getFieldThreadLocalStoreID(CorInfoException** ppException, void* field, void** ppIndirection) = 0;
    virtual void setOverride(CorInfoException** ppException, void* pOverride, void* currentMethod) = 0;
    virtual void addActiveDependency(CorInfoException** ppException, void* moduleFrom, void* moduleTo) = 0;
    virtual void* GetDelegateCtor(CorInfoException** ppException, void* methHnd, void* clsHnd, void* targetMethodHnd, void* pCtorData) = 0;
    virtual void MethodCompileComplete(CorInfoException** ppException, void* methHnd) = 0;
    virtual void* getTailCallCopyArgsThunk(CorInfoException** ppException, void* pSig, int flags) = 0;
    virtual void* getMemoryManager(CorInfoException** ppException) = 0;
    virtual void allocMem(CorInfoException** ppException, unsigned int hotCodeSize, unsigned int coldCodeSize, unsigned int roDataSize, unsigned int xcptnsCount, int flag, void** hotCodeBlock, void** coldCodeBlock, void** roDataBlock) = 0;
    virtual void reserveUnwindInfo(CorInfoException** ppException, bool isFunclet, bool isColdCode, unsigned int unwindSize) = 0;
    virtual void allocUnwindInfo(CorInfoException** ppException, unsigned char* pHotCode, unsigned char* pColdCode, unsigned int startOffset, unsigned int endOffset, unsigned int unwindSize, unsigned char* pUnwindBlock, int funcKind) = 0;
    virtual void* allocGCInfo(CorInfoException** ppException, size_t size) = 0;
    virtual void yieldExecution(CorInfoException** ppException) = 0;
    virtual void setEHcount(CorInfoException** ppException, unsigned cEH) = 0;
    virtual void setEHinfo(CorInfoException** ppException, unsigned EHnumber, void* clause) = 0;
    virtual bool logMsg(CorInfoException** ppException, unsigned level, const char* fmt, va_list args) = 0;
    virtual int doAssert(CorInfoException** ppException, const char* szFile, int iLine, const char* szExpr) = 0;
    virtual void reportFatalError(CorInfoException** ppException, int result) = 0;
    virtual int allocBBProfileBuffer(CorInfoException** ppException, unsigned int count, void** profileBuffer) = 0;
    virtual int getBBProfileData(CorInfoException** ppException, void* ftnHnd, unsigned long* count, void** profileBuffer, unsigned long* numRuns) = 0;
    virtual void recordCallSite(CorInfoException** ppException, unsigned int instrOffset, void* callSig, void* methodHandle) = 0;
    virtual void recordRelocation(CorInfoException** ppException, void* location, void* target, unsigned short fRelocType, unsigned short slotNum, int addlDelta) = 0;
    virtual unsigned short getRelocTypeHint(CorInfoException** ppException, void* target) = 0;
    virtual void getModuleNativeEntryPointRange(CorInfoException** ppException, void** pStart, void** pEnd) = 0;
    virtual unsigned int getExpectedTargetArchitecture(CorInfoException** ppException) = 0;

};

class JitInterfaceWrapper
{
public:
    virtual unsigned int getMethodAttribs(void* ftn)
    {
        CorInfoException* pException = nullptr;
        unsigned int _ret = _pCorInfo->getMethodAttribs(&pException, ftn);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void setMethodAttribs(void* ftn, int attribs)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->setMethodAttribs(&pException, ftn, attribs);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void getMethodSig(void* ftn, void* sig, void* memberParent)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->getMethodSig(&pException, ftn, sig, memberParent);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual bool getMethodInfo(void* ftn, void* info)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->getMethodInfo(&pException, ftn, info);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int canInline(void* callerHnd, void* calleeHnd, unsigned int* pRestrictions)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->canInline(&pException, callerHnd, calleeHnd, pRestrictions);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void reportInliningDecision(void* inlinerHnd, void* inlineeHnd, int inlineResult, const char* reason)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->reportInliningDecision(&pException, inlinerHnd, inlineeHnd, inlineResult, reason);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual bool canTailCall(void* callerHnd, void* declaredCalleeHnd, void* exactCalleeHnd, bool fIsTailPrefix)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->canTailCall(&pException, callerHnd, declaredCalleeHnd, exactCalleeHnd, fIsTailPrefix);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void reportTailCallDecision(void* callerHnd, void* calleeHnd, bool fIsTailPrefix, int tailCallResult, const char* reason)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->reportTailCallDecision(&pException, callerHnd, calleeHnd, fIsTailPrefix, tailCallResult, reason);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void getEHinfo(void* ftn, unsigned EHnumber, void* clause)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->getEHinfo(&pException, ftn, EHnumber, clause);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void* getMethodClass(void* method)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getMethodClass(&pException, method);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getMethodModule(void* method)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getMethodModule(&pException, method);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void getMethodVTableOffset(void* method, unsigned* offsetOfIndirection, unsigned* offsetAfterIndirection)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->getMethodVTableOffset(&pException, method, offsetOfIndirection, offsetAfterIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual int getIntrinsicID(void* method)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getIntrinsicID(&pException, method);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool isInSIMDModule(void* classHnd)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->isInSIMDModule(&pException, classHnd);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getUnmanagedCallConv(void* method)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getUnmanagedCallConv(&pException, method);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool pInvokeMarshalingRequired(void* method, void* callSiteSig)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->pInvokeMarshalingRequired(&pException, method, callSiteSig);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool satisfiesMethodConstraints(void* parent, void* method)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->satisfiesMethodConstraints(&pException, parent, method);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool isCompatibleDelegate(void* objCls, void* methodParentCls, void* method, void* delegateCls, int* pfIsOpenDelegate)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->isCompatibleDelegate(&pException, objCls, methodParentCls, method, delegateCls, pfIsOpenDelegate);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool isDelegateCreationAllowed(void* delegateHnd, void* calleeHnd)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->isDelegateCreationAllowed(&pException, delegateHnd, calleeHnd);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int isInstantiationOfVerifiedGeneric(void* method)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->isInstantiationOfVerifiedGeneric(&pException, method);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void initConstraintsForVerification(void* method, int* pfHasCircularClassConstraints, int* pfHasCircularMethodConstraint)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->initConstraintsForVerification(&pException, method, pfHasCircularClassConstraints, pfHasCircularMethodConstraint);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual int canSkipMethodVerification(void* ftnHandle)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->canSkipMethodVerification(&pException, ftnHandle);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void methodMustBeLoadedBeforeCodeIsRun(void* method)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->methodMustBeLoadedBeforeCodeIsRun(&pException, method);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void* mapMethodDeclToMethodImpl(void* method)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->mapMethodDeclToMethodImpl(&pException, method);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void getGSCookie(void* pCookieVal, void** ppCookieVal)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->getGSCookie(&pException, pCookieVal, ppCookieVal);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void resolveToken(void* pResolvedToken)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->resolveToken(&pException, pResolvedToken);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void findSig(void* module, unsigned sigTOK, void* context, void* sig)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->findSig(&pException, module, sigTOK, context, sig);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void findCallSiteSig(void* module, unsigned methTOK, void* context, void* sig)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->findCallSiteSig(&pException, module, methTOK, context, sig);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void* getTokenTypeAsHandle(void* pResolvedToken)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getTokenTypeAsHandle(&pException, pResolvedToken);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int canSkipVerification(void* module)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->canSkipVerification(&pException, module);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool isValidToken(void* module, unsigned metaTOK)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->isValidToken(&pException, module, metaTOK);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool isValidStringRef(void* module, unsigned metaTOK)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->isValidStringRef(&pException, module, metaTOK);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool shouldEnforceCallvirtRestriction(void* scope)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->shouldEnforceCallvirtRestriction(&pException, scope);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int asCorInfoType(void* cls)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->asCorInfoType(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual const char* getClassName(void* cls)
    {
        CorInfoException* pException = nullptr;
        const char* _ret = _pCorInfo->getClassName(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int appendClassName(wchar_t** ppBuf, int* pnBufLen, void* cls, bool fNamespace, bool fFullInst, bool fAssembly)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->appendClassName(&pException, ppBuf, pnBufLen, cls, fNamespace, fFullInst, fAssembly);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool isValueClass(void* cls)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->isValueClass(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool canInlineTypeCheckWithObjectVTable(void* cls)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->canInlineTypeCheckWithObjectVTable(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual unsigned int getClassAttribs(void* cls)
    {
        CorInfoException* pException = nullptr;
        unsigned int _ret = _pCorInfo->getClassAttribs(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool isStructRequiringStackAllocRetBuf(void* cls)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->isStructRequiringStackAllocRetBuf(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getClassModule(void* cls)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getClassModule(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getModuleAssembly(void* mod)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getModuleAssembly(&pException, mod);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual const char* getAssemblyName(void* assem)
    {
        CorInfoException* pException = nullptr;
        const char* _ret = _pCorInfo->getAssemblyName(&pException, assem);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* LongLifetimeMalloc(size_t sz)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->LongLifetimeMalloc(&pException, sz);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void LongLifetimeFree(void* obj)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->LongLifetimeFree(&pException, obj);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual size_t getClassModuleIdForStatics(void* cls, void* pModule, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        size_t _ret = _pCorInfo->getClassModuleIdForStatics(&pException, cls, pModule, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual unsigned getClassSize(void* cls)
    {
        CorInfoException* pException = nullptr;
        unsigned _ret = _pCorInfo->getClassSize(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual unsigned getClassAlignmentRequirement(void* cls, bool fDoubleAlignHint)
    {
        CorInfoException* pException = nullptr;
        unsigned _ret = _pCorInfo->getClassAlignmentRequirement(&pException, cls, fDoubleAlignHint);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual unsigned getClassGClayout(void* cls, unsigned char* gcPtrs)
    {
        CorInfoException* pException = nullptr;
        unsigned _ret = _pCorInfo->getClassGClayout(&pException, cls, gcPtrs);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual unsigned getClassNumInstanceFields(void* cls)
    {
        CorInfoException* pException = nullptr;
        unsigned _ret = _pCorInfo->getClassNumInstanceFields(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getFieldInClass(void* clsHnd, int num)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getFieldInClass(&pException, clsHnd, num);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool checkMethodModifier(void* hMethod, const char* modifier, bool fOptional)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->checkMethodModifier(&pException, hMethod, modifier, fOptional);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getNewHelper(void* pResolvedToken, void* callerHandle)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getNewHelper(&pException, pResolvedToken, callerHandle);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getNewArrHelper(void* arrayCls)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getNewArrHelper(&pException, arrayCls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getCastingHelper(void* pResolvedToken, bool fThrowing)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getCastingHelper(&pException, pResolvedToken, fThrowing);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getSharedCCtorHelper(void* clsHnd)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getSharedCCtorHelper(&pException, clsHnd);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getSecurityPrologHelper(void* ftn)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getSecurityPrologHelper(&pException, ftn);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getTypeForBox(void* cls)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getTypeForBox(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getBoxHelper(void* cls)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getBoxHelper(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getUnBoxHelper(void* cls)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getUnBoxHelper(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void getReadyToRunHelper(void* pResolvedToken, int id, void* pLookup)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->getReadyToRunHelper(&pException, pResolvedToken, id, pLookup);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual const char* getHelperName(int helpFunc)
    {
        CorInfoException* pException = nullptr;
        const char* _ret = _pCorInfo->getHelperName(&pException, helpFunc);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int initClass(void* field, void* method, void* context, bool speculative)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->initClass(&pException, field, method, context, speculative);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void classMustBeLoadedBeforeCodeIsRun(void* cls)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->classMustBeLoadedBeforeCodeIsRun(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void* getBuiltinClass(int classId)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getBuiltinClass(&pException, classId);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getTypeForPrimitiveValueClass(void* cls)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getTypeForPrimitiveValueClass(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool canCast(void* child, void* parent)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->canCast(&pException, child, parent);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool areTypesEquivalent(void* cls1, void* cls2)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->areTypesEquivalent(&pException, cls1, cls2);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* mergeClasses(void* cls1, void* cls2)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->mergeClasses(&pException, cls1, cls2);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getParentType(void* cls)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getParentType(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getChildType(void* clsHnd, void* clsRet)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getChildType(&pException, clsHnd, clsRet);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool satisfiesClassConstraints(void* cls)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->satisfiesClassConstraints(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool isSDArray(void* cls)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->isSDArray(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual unsigned getArrayRank(void* cls)
    {
        CorInfoException* pException = nullptr;
        unsigned _ret = _pCorInfo->getArrayRank(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getArrayInitializationData(void* field, unsigned int size)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getArrayInitializationData(&pException, field, size);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int canAccessClass(void* pResolvedToken, void* callerHandle, void* pAccessHelper)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->canAccessClass(&pException, pResolvedToken, callerHandle, pAccessHelper);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual const char* getFieldName(void* ftn, const char** moduleName)
    {
        CorInfoException* pException = nullptr;
        const char* _ret = _pCorInfo->getFieldName(&pException, ftn, moduleName);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getFieldClass(void* field)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getFieldClass(&pException, field);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getFieldType(void* field, void* structType, void* memberParent)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getFieldType(&pException, field, structType, memberParent);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual unsigned getFieldOffset(void* field)
    {
        CorInfoException* pException = nullptr;
        unsigned _ret = _pCorInfo->getFieldOffset(&pException, field);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool isWriteBarrierHelperRequired(void* field)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->isWriteBarrierHelperRequired(&pException, field);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void getFieldInfo(void* pResolvedToken, void* callerHandle, int flags, void* pResult)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->getFieldInfo(&pException, pResolvedToken, callerHandle, flags, pResult);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual bool isFieldStatic(void* fldHnd)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->isFieldStatic(&pException, fldHnd);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void getBoundaries(void* ftn, unsigned int* cILOffsets, unsigned int** pILOffsets, void* implictBoundaries)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->getBoundaries(&pException, ftn, cILOffsets, pILOffsets, implictBoundaries);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void setBoundaries(void* ftn, unsigned int cMap, void* pMap)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->setBoundaries(&pException, ftn, cMap, pMap);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void getVars(void* ftn, unsigned int* cVars, void* vars, bool* extendOthers)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->getVars(&pException, ftn, cVars, vars, extendOthers);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void setVars(void* ftn, unsigned int cVars, void* vars)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->setVars(&pException, ftn, cVars, vars);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void* allocateArray(unsigned int cBytes)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->allocateArray(&pException, cBytes);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void freeArray(void* array)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->freeArray(&pException, array);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void* getArgNext(void* args)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getArgNext(&pException, args);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getArgType(void* sig, void* args, void* vcTypeRet)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getArgType(&pException, sig, args, vcTypeRet);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getArgClass(void* sig, void* args)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getArgClass(&pException, sig, args);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getHFAType(void* hClass)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getHFAType(&pException, hClass);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int GetErrorHRESULT(void* pExceptionPointers)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->GetErrorHRESULT(&pException, pExceptionPointers);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual unsigned int GetErrorMessage(wchar_t* buffer, unsigned int bufferLength)
    {
        CorInfoException* pException = nullptr;
        unsigned int _ret = _pCorInfo->GetErrorMessage(&pException, buffer, bufferLength);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int FilterException(void* pExceptionPointers);
    virtual void HandleException(void* pExceptionPointers);
    virtual void ThrowExceptionForJitResult(int result)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->ThrowExceptionForJitResult(&pException, result);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void ThrowExceptionForHelper(const void* throwHelper)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->ThrowExceptionForHelper(&pException, throwHelper);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void getEEInfo(void* pEEInfoOut)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->getEEInfo(&pException, pEEInfoOut);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual const wchar_t* getJitTimeLogFilename()
    {
        CorInfoException* pException = nullptr;
        const wchar_t* _ret = _pCorInfo->getJitTimeLogFilename(&pException);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual unsigned int getMethodDefFromMethod(void* hMethod)
    {
        CorInfoException* pException = nullptr;
        unsigned int _ret = _pCorInfo->getMethodDefFromMethod(&pException, hMethod);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual const char* getMethodName(void* ftn, const char** moduleName)
    {
        CorInfoException* pException = nullptr;
        const char* _ret = _pCorInfo->getMethodName(&pException, ftn, moduleName);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual unsigned getMethodHash(void* ftn)
    {
        CorInfoException* pException = nullptr;
        unsigned _ret = _pCorInfo->getMethodHash(&pException, ftn);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual size_t findNameOfToken(void* moduleHandle, unsigned int token, char* szFQName, size_t FQNameCapacity)
    {
        CorInfoException* pException = nullptr;
        size_t _ret = _pCorInfo->findNameOfToken(&pException, moduleHandle, token, szFQName, FQNameCapacity);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool getSystemVAmd64PassStructInRegisterDescriptor(void* structHnd, void* structPassInRegDescPtr)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->getSystemVAmd64PassStructInRegisterDescriptor(&pException, structHnd, structPassInRegDescPtr);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getIntConfigValue(const wchar_t* name, int defaultValue)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getIntConfigValue(&pException, name, defaultValue);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual wchar_t* getStringConfigValue(const wchar_t* name)
    {
        CorInfoException* pException = nullptr;
        wchar_t* _ret = _pCorInfo->getStringConfigValue(&pException, name);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void freeStringConfigValue(wchar_t* value)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->freeStringConfigValue(&pException, value);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual unsigned int getThreadTLSIndex(void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        unsigned int _ret = _pCorInfo->getThreadTLSIndex(&pException, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual const void* getInlinedCallFrameVptr(void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        const void* _ret = _pCorInfo->getInlinedCallFrameVptr(&pException, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual long* getAddrOfCaptureThreadGlobal(void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        long* _ret = _pCorInfo->getAddrOfCaptureThreadGlobal(&pException, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual size_t* getAddrModuleDomainID(void* module)
    {
        CorInfoException* pException = nullptr;
        size_t* _ret = _pCorInfo->getAddrModuleDomainID(&pException, module);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getHelperFtn(int ftnNum, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getHelperFtn(&pException, ftnNum, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void getFunctionEntryPoint(void* ftn, void* pResult, int accessFlags)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->getFunctionEntryPoint(&pException, ftn, pResult, accessFlags);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void getFunctionFixedEntryPoint(void* ftn, void* pResult)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->getFunctionFixedEntryPoint(&pException, ftn, pResult);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void* getMethodSync(void* ftn, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getMethodSync(&pException, ftn, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getLazyStringLiteralHelper(void* handle)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getLazyStringLiteralHelper(&pException, handle);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* embedModuleHandle(void* handle, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->embedModuleHandle(&pException, handle, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* embedClassHandle(void* handle, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->embedClassHandle(&pException, handle, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* embedMethodHandle(void* handle, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->embedMethodHandle(&pException, handle, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* embedFieldHandle(void* handle, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->embedFieldHandle(&pException, handle, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void embedGenericHandle(void* pResolvedToken, bool fEmbedParent, void* pResult)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->embedGenericHandle(&pException, pResolvedToken, fEmbedParent, pResult);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual CORINFO_LOOKUP_KIND getLocationOfThisType(void* context);
    virtual void* getPInvokeUnmanagedTarget(void* method, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getPInvokeUnmanagedTarget(&pException, method, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getAddressOfPInvokeFixup(void* method, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getAddressOfPInvokeFixup(&pException, method, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* GetCookieForPInvokeCalliSig(void* szMetaSig, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->GetCookieForPInvokeCalliSig(&pException, szMetaSig, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool canGetCookieForPInvokeCalliSig(void* szMetaSig)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->canGetCookieForPInvokeCalliSig(&pException, szMetaSig);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getJustMyCodeHandle(void* method, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getJustMyCodeHandle(&pException, method, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void GetProfilingHandle(int* pbHookFunction, void** pProfilerHandle, int* pbIndirectedHandles)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->GetProfilingHandle(&pException, pbHookFunction, pProfilerHandle, pbIndirectedHandles);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void getCallInfo(void* pResolvedToken, void* pConstrainedResolvedToken, void* callerHandle, int flags, void* pResult)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->getCallInfo(&pException, pResolvedToken, pConstrainedResolvedToken, callerHandle, flags, pResult);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual bool canAccessFamily(void* hCaller, void* hInstanceType)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->canAccessFamily(&pException, hCaller, hInstanceType);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool isRIDClassDomainID(void* cls)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->isRIDClassDomainID(&pException, cls);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual unsigned getClassDomainID(void* cls, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        unsigned _ret = _pCorInfo->getClassDomainID(&pException, cls, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getFieldAddress(void* field, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getFieldAddress(&pException, field, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getVarArgsHandle(void* pSig, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getVarArgsHandle(&pException, pSig, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual bool canGetVarArgsHandle(void* pSig)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->canGetVarArgsHandle(&pException, pSig);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int constructStringLiteral(void* module, unsigned int metaTok, void** ppValue)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->constructStringLiteral(&pException, module, metaTok, ppValue);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int emptyStringLiteral(void** ppValue)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->emptyStringLiteral(&pException, ppValue);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual unsigned int getFieldThreadLocalStoreID(void* field, void** ppIndirection)
    {
        CorInfoException* pException = nullptr;
        unsigned int _ret = _pCorInfo->getFieldThreadLocalStoreID(&pException, field, ppIndirection);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void setOverride(void* pOverride, void* currentMethod)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->setOverride(&pException, pOverride, currentMethod);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void addActiveDependency(void* moduleFrom, void* moduleTo)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->addActiveDependency(&pException, moduleFrom, moduleTo);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void* GetDelegateCtor(void* methHnd, void* clsHnd, void* targetMethodHnd, void* pCtorData)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->GetDelegateCtor(&pException, methHnd, clsHnd, targetMethodHnd, pCtorData);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void MethodCompileComplete(void* methHnd)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->MethodCompileComplete(&pException, methHnd);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void* getTailCallCopyArgsThunk(void* pSig, int flags)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getTailCallCopyArgsThunk(&pException, pSig, flags);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void* getMemoryManager()
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->getMemoryManager(&pException);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void allocMem(unsigned int hotCodeSize, unsigned int coldCodeSize, unsigned int roDataSize, unsigned int xcptnsCount, int flag, void** hotCodeBlock, void** coldCodeBlock, void** roDataBlock)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->allocMem(&pException, hotCodeSize, coldCodeSize, roDataSize, xcptnsCount, flag, hotCodeBlock, coldCodeBlock, roDataBlock);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void reserveUnwindInfo(bool isFunclet, bool isColdCode, unsigned int unwindSize)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->reserveUnwindInfo(&pException, isFunclet, isColdCode, unwindSize);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void allocUnwindInfo(unsigned char* pHotCode, unsigned char* pColdCode, unsigned int startOffset, unsigned int endOffset, unsigned int unwindSize, unsigned char* pUnwindBlock, int funcKind)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->allocUnwindInfo(&pException, pHotCode, pColdCode, startOffset, endOffset, unwindSize, pUnwindBlock, funcKind);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void* allocGCInfo(size_t size)
    {
        CorInfoException* pException = nullptr;
        void* _ret = _pCorInfo->allocGCInfo(&pException, size);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void yieldExecution()
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->yieldExecution(&pException);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void setEHcount(unsigned cEH)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->setEHcount(&pException, cEH);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void setEHinfo(unsigned EHnumber, void* clause)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->setEHinfo(&pException, EHnumber, clause);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual bool logMsg(unsigned level, const char* fmt, va_list args)
    {
        CorInfoException* pException = nullptr;
        bool _ret = _pCorInfo->logMsg(&pException, level, fmt, args);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int doAssert(const char* szFile, int iLine, const char* szExpr)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->doAssert(&pException, szFile, iLine, szExpr);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void reportFatalError(int result)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->reportFatalError(&pException, result);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual int allocBBProfileBuffer(unsigned int count, void** profileBuffer)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->allocBBProfileBuffer(&pException, count, profileBuffer);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual int getBBProfileData(void* ftnHnd, unsigned long* count, void** profileBuffer, unsigned long* numRuns)
    {
        CorInfoException* pException = nullptr;
        int _ret = _pCorInfo->getBBProfileData(&pException, ftnHnd, count, profileBuffer, numRuns);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void recordCallSite(unsigned int instrOffset, void* callSig, void* methodHandle)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->recordCallSite(&pException, instrOffset, callSig, methodHandle);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual void recordRelocation(void* location, void* target, unsigned short fRelocType, unsigned short slotNum, int addlDelta)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->recordRelocation(&pException, location, target, fRelocType, slotNum, addlDelta);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual unsigned short getRelocTypeHint(void* target)
    {
        CorInfoException* pException = nullptr;
        unsigned short _ret = _pCorInfo->getRelocTypeHint(&pException, target);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }
    virtual void getModuleNativeEntryPointRange(void** pStart, void** pEnd)
    {
        CorInfoException* pException = nullptr;
        _pCorInfo->getModuleNativeEntryPointRange(&pException, pStart, pEnd);
        if (pException != nullptr)
        {
            throw pException;
        }
    }
    virtual unsigned int getExpectedTargetArchitecture()
    {
        CorInfoException* pException = nullptr;
        unsigned int _ret = _pCorInfo->getExpectedTargetArchitecture(&pException);
        if (pException != nullptr)
        {
            throw pException;
        }
        return _ret;
    }

    IJitInterface *_pCorInfo;
};
